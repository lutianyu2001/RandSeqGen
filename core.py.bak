#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Tianyu (Sky) Lu (tianyu@lu.fm)

from typing import Tuple, List, Dict, Optional
from Bio.SeqRecord import SeqRecord

from utils import create_sequence_record, generate_TSD


class SequenceNode:
    """
    Node in a sequence tree structure, used for efficient sequence insertion operations.
    Implemented as an AVL tree to maintain balance during insertions.
    """
    def __init__(self, data: str, is_donor: bool = False, donor_id: str = None, uid: int = None):
        """
        Initialize a sequence node.

        Args:
            data (str): The sequence string
            is_donor (bool): Whether this node contains a donor sequence
            donor_id (str): Identifier for the donor sequence (if is_donor is True)
            uid (int): Unique identifier for this node
        """
        self.data = data
        self.length = len(data)
        self.is_donor = is_donor
        self.donor_id = donor_id
        self.left = None
        self.right = None
        self.uid = uid

        # Total length of the subtree for efficient traversal
        self.total_length = self.length
        # Height of the node for AVL balancing
        self.height = 1

    def __iter__(self):
        """
        Implement in-order traversal of the tree, iterating all nodes in left-root-right order
        Yields:
            SequenceNode: Each node in the tree
        """
        yield from SequenceNode._inorder_traversal(self)

    @staticmethod
    def _inorder_traversal(node):
        if not node:
            return
        yield from SequenceNode._inorder_traversal(node.left)
        yield node
        yield from SequenceNode._inorder_traversal(node.right)

    def __str__(self) -> str:
        """
        Convert the tree to a string by in-order traversal.

        Returns:
            str: The concatenated sequence
        """
        return "".join([node.data for node in self])

    def update_height(self):
        """
        Update the height of this node.
        """
        left_height = self.left.height if self.left else 0
        right_height = self.right.height if self.right else 0
        self.height = max(left_height, right_height) + 1

    def update_total_length(self):
        """
        Update the total length of this subtree.

        This method recalculates the total length of the subtree rooted at this node
        by summing the lengths of the left subtree, the current node, and the right subtree.
        """
        left_length = self.left.total_length if self.left else 0
        right_length = self.right.total_length if self.right else 0
        self.total_length = left_length + self.length + right_length

    def update(self):
        self.update_height()
        self.update_total_length()

    def get_balance_factor(self):
        """
        Calculate the balance factor of this node.

        Returns:
            int: Balance factor (left height - right height)
        """
        left_height = self.left.height if self.left else 0
        right_height = self.right.height if self.right else 0
        return left_height - right_height

    def rotate_right(self):
        """
        Perform a right rotation on this node.

        Returns:
            SequenceNode: The new root after rotation
        """
        # Store the left child as the new root
        new_root = self.left

        # The left child's right subtree becomes this node's left subtree
        self.left = new_root.right

        # This node becomes the new root's right child
        new_root.right = self

        self.update()
        new_root.update()
        return new_root

    def rotate_left(self):
        """
        Perform a left rotation on this node.

        Returns:
            SequenceNode: The new root after rotation
        """
        # Store the right child as the new root
        new_root = self.right

        # The right child's left subtree becomes this node's right subtree
        self.right = new_root.left

        # This node becomes the new root's left child
        new_root.left = self

        self.update()
        new_root.update()
        return new_root

    def balance(self):
        """
        Balance this node if needed.

        Returns:
            SequenceNode: The new root after balancing
        """
        self.update_height()
        balance = self.get_balance_factor()

        # Left-Left case
        if balance > 1 and (self.left and self.__get_left_balance() >= 0):
            return self.rotate_right()

        # Left-Right case
        if balance > 1 and (self.left and self.__get_left_balance() < 0):
            self.left = self.left.rotate_left()
            return self.rotate_right()

        # Right-Right case
        if balance < -1 and (self.right and self.__get_right_balance() <= 0):
            return self.rotate_left()

        # Right-Left case
        if balance < -1 and (self.right and self.__get_right_balance() > 0):
            self.right = self.right.rotate_right()
            return self.rotate_left()

        return self

    def __get_left_balance(self):
        """Get balance factor of left child"""
        return self.left.get_balance_factor() if self.left else 0

    def __get_right_balance(self):
        """Get balance factor of right child"""
        return self.right.get_balance_factor() if self.right else 0

class HierarchicalNestingGraph:
    """
    A hierarchical graph representing donor sequence insertions and their nesting relationships.
    Efficiently tracks and rebuilds nested donor sequences.
    """
    def __init__(self):
        """Initialize the hierarchical nesting graph with empty data structures."""
        # Store basic node information
        self.nodes = {}  # uid → {sequence, donor_id, position, length}
        
        # Store cutting relationships
        self.cuts = {}  # target_uid → [(position, cutter_uid, left_uid, right_uid, tsd_info)]
        
        # Store fragment information
        self.fragments = {}  # fragment_uid → (original_uid, position, is_left, cutter_uid)
        
        # Store reverse index of cutting relationships
        self.cut_targets = {}  # cutter_uid → [target_uid]

    def add_node(self, uid: int, sequence: str, donor_id: str = None, position: int = None):
        """
        Add a node to the graph.
        
        Args:
            uid: Node unique identifier
            sequence: Node sequence content
            donor_id: Donor identifier (optional)
            position: Insertion position (optional)
            
        Returns:
            self for method chaining
        """
        self.nodes[uid] = {
            'sequence': sequence,
            'length': len(sequence),
            'donor_id': donor_id,
            'position': position
        }
        return self
        
    def record_cut(self, target_uid: int, position: int, cutter_uid: int, 
                  left_uid: int, right_uid: int, tsd_info: dict = None):
        """
        Record a cutting relationship in the graph.
        
        Args:
            target_uid: The node being cut
            position: Cut position in the target sequence
            cutter_uid: The node performing the cut
            left_uid: Left fragment node uid
            right_uid: Right fragment node uid
            tsd_info: Target Site Duplication information (optional)
            
        Returns:
            self for method chaining
        """
        # Verify all node UIDs exist
        if not all(uid in self.nodes for uid in [target_uid, cutter_uid, left_uid, right_uid]):
            return self
            
        # Initialize cuts entry if not present
        if target_uid not in self.cuts:
            self.cuts[target_uid] = []
            
        # Add cut record
        cut_record = (position, cutter_uid, left_uid, right_uid, tsd_info or {})
        self.cuts[target_uid].append(cut_record)
        
        # Sort cuts by position
        self.cuts[target_uid].sort(key=lambda x: x[0])
        
        # Update reverse index
        if cutter_uid not in self.cut_targets:
            self.cut_targets[cutter_uid] = []
        if target_uid not in self.cut_targets[cutter_uid]:
            self.cut_targets[cutter_uid].append(target_uid)
            
        # Record fragment information
        self.fragments[left_uid] = (target_uid, position, True, cutter_uid)
        self.fragments[right_uid] = (target_uid, position, False, cutter_uid)
        
        return self
        
    def add_cut_relation(self, cutter_uid: int, cut_uid: int, left_uid: int, right_uid: int):
        """
        Add a cutting relationship. Compatibility method for the old interface.

        Args:
            cutter_uid: The donor performing the cut
            cut_uid: The donor being cut
            left_uid: Left fragment UID
            right_uid: Right fragment UID
            
        Returns:
            self for method chaining
        """
        # Get the position from the cutter node
        position = self.nodes.get(cutter_uid, {}).get('position', 0)
        
        # Use record_cut to add the relationship
        return self.record_cut(cut_uid, position, cutter_uid, left_uid, right_uid)
        
    def update_uid(self, old_uid: int, new_uid: int):
        """
        Update all references to old_uid with new_uid throughout the graph.

        Args:
            old_uid: The uid to replace
            new_uid: The new uid to use
            
        Returns:
            self for method chaining
        """
        # Skip if old_uid and new_uid are the same
        if old_uid == new_uid:
            return self

        # 1. Update nodes dict
        if old_uid in self.nodes:
            self.nodes[new_uid] = self.nodes.pop(old_uid)
            
        # 2. Update cuts dict (as target)
        if old_uid in self.cuts:
            self.cuts[new_uid] = self.cuts.pop(old_uid)
            
        # 3. Update references within cuts
        for target_uid in list(self.cuts.keys()):
            for i, (position, cutter, left, right, tsd) in enumerate(self.cuts[target_uid]):
                updated_record = (
                    position,
                    new_uid if cutter == old_uid else cutter,
                    new_uid if left == old_uid else left,
                    new_uid if right == old_uid else right,
                    tsd
                )
                self.cuts[target_uid][i] = updated_record
                
        # 4. Update fragments dict (as fragment)
        if old_uid in self.fragments:
            self.fragments[new_uid] = self.fragments.pop(old_uid)
            
        # 5. Update references within fragments
        for frag_uid in list(self.fragments.keys()):
            orig, pos, is_left, cutter = self.fragments[frag_uid]
            updated_record = (
                new_uid if orig == old_uid else orig,
                pos,
                is_left,
                new_uid if cutter == old_uid else cutter
            )
            self.fragments[frag_uid] = updated_record
            
        # 6. Update cut_targets dict (as cutter)
        if old_uid in self.cut_targets:
            self.cut_targets[new_uid] = self.cut_targets.pop(old_uid)
            
        # 7. Update references within cut_targets
        for cutter_uid in self.cut_targets:
            targets = self.cut_targets[cutter_uid]
            self.cut_targets[cutter_uid] = [new_uid if t == old_uid else t for t in targets]

        return self

    def is_fragment(self, uid: int) -> bool:
        """Check if a node is a fragment."""
        return uid in self.fragments

    def is_donor(self, uid: int) -> bool:
        """Check if a node is a donor."""
        return uid in self.nodes and self.nodes[uid].get('donor_id') is not None
        
    def is_cut(self, uid: int) -> bool:
        """Check if a node has been cut."""
        return uid in self.cuts and len(self.cuts[uid]) > 0
        
    def get_fragments(self, uid: int) -> list:
        """Get all fragments of a given original node."""
        return [frag_uid for frag_uid, (orig_uid, _, _, _) in self.fragments.items() 
                if orig_uid == uid]
                
    def get_cutters(self, uid: int) -> list:
        """Get all cutters of a given node."""
        if uid in self.cuts:
            return [cutter_uid for _, cutter_uid, _, _, _ in self.cuts[uid]]
        return []
        
    def get_cut_targets(self, uid: int) -> list:
        """Get all targets cut by a given cutter."""
        return self.cut_targets.get(uid, [])
        
    def _topological_sort(self, uids=None) -> list:
        """
        Perform topological sort on nodes based on cut dependencies.
        
        Args:
            uids: Optional list of uids to sort (defaults to all)
            
        Returns:
            Topologically sorted list of uids
        """
        if uids is None:
            uids = list(self.nodes.keys())
            
        # Build dependency graph
        dependencies = {uid: set() for uid in uids}
        for uid in uids:
            if uid in self.cuts:
                for _, cutter_uid, _, _, _ in self.cuts[uid]:
                    if cutter_uid in uids:
                        dependencies[cutter_uid].add(uid)
                        
        # Calculate in-degrees
        in_degree = {uid: 0 for uid in uids}
        for uid in uids:
            for dep in dependencies[uid]:
                in_degree[dep] += 1
                
        # Topological sort using BFS
        queue = [uid for uid in uids if in_degree[uid] == 0]
        result = []
        
        while queue:
            node = queue.pop(0)
            result.append(node)
            
            for dep in dependencies[node]:
                in_degree[dep] -= 1
                if in_degree[dep] == 0:
                    queue.append(dep)
                    
        # Check for cycles
        if len(result) != len(uids):
            # Handle cycle by adding remaining nodes in some order
            for uid in uids:
                if uid not in result:
                    result.append(uid)
                    
        return result
        
    def rebuild_sequence(self, uid: int) -> str:
        """
        Rebuild the complete sequence with all nested insertions.

        Args:
            uid: Node uid to rebuild

        Returns:
            Reconstructed sequence
        """
        # Get original sequence
        if uid not in self.nodes:
            return ""
        
        sequence = self.nodes[uid]['sequence']
        
        # If no cuts, return original
        if uid not in self.cuts or not self.cuts[uid]:
            return sequence
            
        # Get all cuts and sort by position (largest first)
        cuts = sorted(self.cuts[uid], key=lambda x: x[0], reverse=True)
        
        # Apply cuts from largest position to smallest
        for position, cutter_uid, left_uid, right_uid, tsd_info in cuts:
            # Rebuild cutter sequence
            cutter_seq = self.rebuild_sequence(cutter_uid)
            
            # Handle TSD if present
            if tsd_info and 'length' in tsd_info and tsd_info['length'] > 0:
                # Apply TSD modifications based on available TSD information
                tsd_len = tsd_info.get('length', 0)
                if tsd_len > 0:
                    if 'tsd_5' in tsd_info and 'tsd_3' in tsd_info:
                        # Use provided TSD sequences
                        tsd_5 = tsd_info.get('tsd_5', '')
                        tsd_3 = tsd_info.get('tsd_3', '')
                    else:
                        # Extract from the original sequence
                        source_tsd = sequence[position:position+min(tsd_len, len(sequence)-position)]
                        tsd_5 = tsd_3 = source_tsd
                        
                    # Insert cutter with TSD
                    sequence = sequence[:position] + tsd_5 + cutter_seq + tsd_3 + sequence[position:]
                else:
                    # No TSD, simple insertion
                    sequence = sequence[:position] + cutter_seq + sequence[position:]
            else:
                # No TSD, simple insertion
                sequence = sequence[:position] + cutter_seq + sequence[position:]
                
        return sequence
        
    def rebuild_clean_sequence(self, uid: int) -> str:
        """
        Rebuild the sequence without nested insertions.
        
        Args:
            uid: Node uid to rebuild
            
        Returns:
            Clean sequence with all insertions removed
        """
        # Get original sequence
        if uid not in self.nodes:
            return ""
            
        sequence = self.nodes[uid]['sequence']
        
        # If no cuts, return original
        if uid not in self.cuts or not self.cuts[uid]:
            return sequence
            
        # For fragments, retrieve and rebuild the original
        if uid in self.fragments:
            original_uid, _, _, _ = self.fragments[uid]
            return self.rebuild_clean_sequence(original_uid)
            
        # Get all cuts and sort by position (largest first)
        cuts = sorted(self.cuts[uid], key=lambda x: x[0], reverse=True)
        
        # Join left and right fragments directly
        left_fragments = []
        right_fragments = []
        
        for position, _, left_uid, right_uid, tsd_info in cuts:
            left_seq = self.nodes[left_uid]['sequence']
            right_seq = self.nodes[right_uid]['sequence']
            
            # Handle TSD if present
            if tsd_info and 'length' in tsd_info and tsd_info['length'] > 0:
                tsd_len = tsd_info.get('length', 0)
                # Remove duplicate TSD
                if len(right_seq) > tsd_len:
                    right_seq = right_seq[tsd_len:]
                
            # Build clean sequence by combining fragments
            sequence = left_seq + right_seq
            
        return sequence
        
    def generate_donor_records(self, seq_id: str) -> tuple:
        """
        Generate donor sequence records with reconstructions.
        
        Args:
            seq_id: Base sequence identifier
            
        Returns:
            (donor_records, reconstructed_donors)
        """
        from utils import create_sequence_record
        
        donor_records = []
        reconstructed_donors = []
        
        # Find all donor nodes (those with donor_id)
        donor_uids = [uid for uid, info in self.nodes.items() 
                     if info.get('donor_id') is not None]
                     
        # Find cut donors
        cut_donors = [uid for uid in donor_uids if self.is_cut(uid)]
        
        # Generate records for each donor
        for uid in donor_uids:
            node_info = self.nodes[uid]
            
            # Skip fragments
            if self.is_fragment(uid):
                        continue

            # Get position information
            position = node_info.get('position', 0)
            
            # Create donor record
            donor_id = f"{seq_id}_{position}_{position+node_info['length']}-+-{node_info['length']}"
            if node_info.get('donor_id'):
                donor_id += f"-{node_info['donor_id']}"
                
            donor_seq = node_info['sequence']
            donor_record = create_sequence_record(donor_seq, donor_id)
            donor_record.annotations["uid"] = uid
            donor_record.annotations["position"] = position
            donor_record.annotations["length"] = node_info['length']
            
            donor_records.append(donor_record)
            
        # Generate reconstructions for cut donors
        for uid in cut_donors:
            node_info = self.nodes[uid]
            position = node_info.get('position', 0)
            
            # Generate full reconstruction with all nested inserts
            full_seq = self.rebuild_sequence(uid)
            full_id = f"{seq_id}_reconstructed_{uid}"
            full_rec = create_sequence_record(full_seq, full_id)
            full_rec.annotations["reconstruction_type"] = "full"
            full_rec.annotations["original_uid"] = uid
            
            # Add all cutters information
            cutters = self.get_cutters(uid)
            if cutters:
                full_rec.annotations["cutters"] = cutters
                
            reconstructed_donors.append(full_rec)
            
            # Generate clean reconstruction without inserts
            clean_seq = self.rebuild_clean_sequence(uid)
            clean_id = f"{seq_id}_clean_reconstructed_{uid}"
            clean_rec = create_sequence_record(clean_seq, clean_id)
            clean_rec.annotations["reconstruction_type"] = "clean"
            clean_rec.annotations["original_uid"] = uid
            
            # Add multiple cuts annotation if needed
            if len(cutters) > 1:
                clean_rec.annotations["multiple_cuts"] = True
                clean_rec.annotations["cut_count"] = len(cutters)
                clean_rec.annotations["all_cutters"] = cutters
                
            reconstructed_donors.append(clean_rec)
            
        return donor_records, reconstructed_donors

    def to_graphviz_dot(self) -> str:
        """
        Generate a Graphviz DOT representation for visualization.

        Returns:
            Graphviz DOT format string
        """
        # Initialize DOT string
        dot_lines = ["digraph HierarchicalNestingGraph {",
                      "  bgcolor=\"#FFF\";",
                      "  node [fontcolor=\"#000\", shape=box, style=filled];",
                      "  edge [fontcolor=\"#000\", penwidth=2.0];"]
        
        # Generate nodes
        for uid, info in self.nodes.items():
            # Determine node type and color
            if self.is_fragment(uid):
                # Get fragment info
                orig_uid, pos, is_left, cutter_uid = self.fragments[uid]
                
                # Set color based on fragment type
                if is_left:
                    color = "lightblue"
                    node_type = "L Fragment"
                else:
                    color = "lightpink"
                    node_type = "R Fragment"
                    
                # Create label
                label = f"{node_type}\\nUID: {uid}\\nFrom: {orig_uid}\\nLen: {info['length']}"
                
            elif self.is_donor(uid):
                if uid in self.cut_targets and self.cut_targets[uid]:
                    # This is a cutter
                    color = "moccasin"
                    node_type = "Cutter"
                else:
                    # Regular donor
                    color = "lightgreen"
                    node_type = "Donor"
                    
                # Create label
                position = info.get('position', 'N/A')
                label = f"{node_type}\\nUID: {uid}\\nLen: {info['length']}"
                if position != 'N/A':
                    label += f"\\nPos: {position}"
                if info.get('donor_id'):
                    label += f"\\nID: {info['donor_id']}"
            else:
                # Regular node
                color = "lightgrey"
                node_type = "Node"
                
                # Create label
                label = f"{node_type}\\nUID: {uid}\\nLen: {info['length']}"
                
            # Add node to DOT
            dot_lines.append(f'  node_{uid} [label="{label}", fillcolor="{color}"];')
            
        # Generate edges
        for target_uid, cuts in self.cuts.items():
            for position, cutter_uid, left_uid, right_uid, _ in cuts:
                # Add cutter to target edge
                dot_lines.append(f'  node_{cutter_uid} -> node_{target_uid} [label="cuts@{position}", color="black"];')
                
                # Add target to fragments edges
                dot_lines.append(f'  node_{target_uid} -> node_{left_uid} [label="L", style="dashed", color="blue"];')
                dot_lines.append(f'  node_{target_uid} -> node_{right_uid} [label="R", style="dashed", color="red"];')
                
        # Close graph
        dot_lines.append("}")
        
        return "\n".join(dot_lines)
        
    def validate_graph(self) -> tuple:
        """
        Validate graph consistency.
        
        Returns:
            (is_valid, errors)
        """
        errors = []
        
        # Check that all referenced UIDs exist
        referenced_uids = set()
        
        # Collect references from cuts
        for target_uid, cut_list in self.cuts.items():
            referenced_uids.add(target_uid)
            for _, cutter_uid, left_uid, right_uid, _ in cut_list:
                referenced_uids.update([cutter_uid, left_uid, right_uid])
                
        # Collect references from fragments
        for frag_uid, (orig_uid, _, _, cutter_uid) in self.fragments.items():
            referenced_uids.update([frag_uid, orig_uid, cutter_uid])
            
        # Collect references from cut_targets
        for cutter_uid, target_list in self.cut_targets.items():
            referenced_uids.add(cutter_uid)
            referenced_uids.update(target_list)
            
        # Check for undefined references
        undefined_uids = referenced_uids - set(self.nodes.keys())
        if undefined_uids:
            errors.append(f"Undefined UID references: {undefined_uids}")
            
        # Check consistency between cuts and fragments
        for target_uid, cut_list in self.cuts.items():
            for _, cutter_uid, left_uid, right_uid, _ in cut_list:
                # Verify left fragment reference
                if left_uid not in self.fragments:
                    errors.append(f"Left fragment {left_uid} not in fragments dictionary")
                else:
                    frag_orig, _, is_left, frag_cutter = self.fragments[left_uid]
                    if frag_orig != target_uid or not is_left or frag_cutter != cutter_uid:
                        errors.append(f"Fragment {left_uid} has inconsistent information")
                        
                # Verify right fragment reference
                if right_uid not in self.fragments:
                    errors.append(f"Right fragment {right_uid} not in fragments dictionary")
                else:
                    frag_orig, _, is_left, frag_cutter = self.fragments[right_uid]
                    if frag_orig != target_uid or is_left or frag_cutter != cutter_uid:
                        errors.append(f"Fragment {right_uid} has inconsistent information")
                        
        # Check consistency between cuts and cut_targets
        for target_uid, cut_list in self.cuts.items():
            for _, cutter_uid, _, _, _ in cut_list:
                if cutter_uid not in self.cut_targets:
                    errors.append(f"Cutter {cutter_uid} not in cut_targets dictionary")
                elif target_uid not in self.cut_targets[cutter_uid]:
                    errors.append(f"Target {target_uid} not in cut_targets[{cutter_uid}]")
                    
        for cutter_uid, target_list in self.cut_targets.items():
            for target_uid in target_list:
                if target_uid not in self.cuts:
                    errors.append(f"Target {target_uid} in cut_targets but not in cuts")
                else:
                    cutter_found = False
                    for _, cut_cutter, _, _, _ in self.cuts[target_uid]:
                        if cut_cutter == cutter_uid:
                            cutter_found = True
                            break
                    if not cutter_found:
                        errors.append(f"Cutter {cutter_uid} not found in cuts[{target_uid}]")
                        
        return len(errors) == 0, errors
        
    def calculate_nesting_depth(self, uid: int, visited=None) -> int:
        """
        Calculate the nesting depth of a node.
        
        Args:
            uid: Node uid
            visited: Set of visited nodes to prevent infinite recursion
            
        Returns:
            Nesting depth
        """
        if visited is None:
            visited = set()
            
        # Check for already visited or non-existent node
        if uid in visited or uid not in self.nodes:
            return 0
            
        visited.add(uid)
        
        # If node has no cuts, depth is 0
        if uid not in self.cuts or not self.cuts[uid]:
            return 0
            
        # Calculate maximum depth of cutters
        max_depth = 0
        for _, cutter_uid, _, _, _ in self.cuts[uid]:
            # Skip already visited nodes to avoid cycles
            if cutter_uid not in visited:
                cutter_depth = self.calculate_nesting_depth(cutter_uid, visited.copy())
                max_depth = max(max_depth, cutter_depth)
                
        # Return max depth + 1 for this level
        return max_depth + 1
        
    def reconstruct_donors(self, seq_id: str) -> tuple:
        """
        Compatibility method for DonorNestingGraph interface.
        
        Args:
            seq_id: Base sequence identifier
            
        Returns:
            (reconstructed_donors, excluded_uids)
        """
        # Get donor records and reconstructions
        donor_records, reconstructed = self.generate_donor_records(seq_id)
        
        # Determine excluded UIDs (those with reconstructions)
        excluded_uids = set()
        for record in reconstructed:
            if "original_uid" in record.annotations:
                excluded_uids.add(record.annotations["original_uid"])
                
        return reconstructed, excluded_uids

    # Compatibility methods for older interface
    def get_original_donor(self, uid: int) -> int:
        """Get the original donor UID for a fragment."""
        if uid in self.fragments:
            return self.fragments[uid][0]
        return uid
        
    def get_fragment_cutter(self, uid: int) -> int:
        """Get the cutter that produced a fragment."""
        if uid in self.fragments:
            return self.fragments[uid][3]
        return None
        
    def get_all_fragments(self, original_uid: int) -> list:
        """Get all fragments of a given original donor."""
        return self.get_fragments(original_uid)
        
    def get_fragments_by_cutter(self, original_uid: int, cutter_uid: int) -> list:
        """Get fragments of a donor produced by a specific cutter."""
        return [uid for uid, (orig, _, _, cutter) in self.fragments.items() 
                if orig == original_uid and cutter == cutter_uid]
                
    def get_cut_by(self, cut_uid: int) -> list:
        """Get all cutters that cut a specific donor."""
        return [(cutter, left, right) for pos, cutter, left, right, _ in self.cuts.get(cut_uid, [])]
        
    def get_cuts(self, cutter_uid: int) -> list:
        """Get all donors cut by a specific cutter."""
        result = []
        for target in self.cut_targets.get(cutter_uid, []):
            for pos, cutter, left, right, _ in self.cuts.get(target, []):
                if cutter == cutter_uid:
                    result.append((target, left, right))
        return result

class SequenceTree:
    """
    Manages a tree of SequenceNode objects, with its own UID management system.
    Provides high-level operations for sequence insertion and traversal.
    """
    def __init__(self, initial_seq: str, base_uid: int = 0):
        """
        Initialize a new sequence tree with a root node containing the initial sequence.

        Args:
            initial_seq (str): The initial sequence to store in the root node
            base_uid (int): Base UID for this tree's UID management system
        """
        # Initialize UID management system
        self.next_uid = base_uid
        self.available_uids = []
        self.node_dict = {}

        # Create the root node
        self.root = self._create_node(initial_seq, False)

        # 创建嵌套关系图
        self.nesting_graph = HierarchicalNestingGraph()

        # 将根节点添加到嵌套关系图
        self.nesting_graph.add_node(self.root.uid, initial_seq)

    def __str__(self) -> str:
        """
        Convert the tree to a string.

        Returns:
            str: The concatenated sequence
        """
        return str(self.root) if self.root else ""

    def __iter__(self):
        yield from self.root

    def _get_next_uid(self) -> int:
        """Get the next available UID from the UID management system"""
        if self.available_uids:
            return self.available_uids.pop(0)

        uid = self.next_uid
        self.next_uid += 1
        return uid

    def _release_uid(self, uid: int):
        """Release an UID back to the UID management system"""
        if uid in self.node_dict:
            del self.node_dict[uid]

        if uid not in self.available_uids:
            self.available_uids.append(uid)

    def _create_node(self, data: str, is_donor: bool = False, donor_id: str = None, uid: int = None) -> SequenceNode:
        """
        Create a new SequenceNode with a unique UID.

        Args:
            data (str): Sequence data
            is_donor (bool): Whether this node contains a donor sequence
            donor_id (str): Donor ID for tracking and visualization
            uid (int): 预设的UID，如果提供则使用此UID

        Returns:
            SequenceNode: The newly created node
        """
        uid = uid or self._get_next_uid()
        node = SequenceNode(data, is_donor, donor_id, uid)
        self.node_dict[uid] = node
        return node

    def insert(self, abs_position: int, donor_seq: str, donor_id: str = None, tsd_length: int = 0,
               recursive: bool = False, debug: bool = False) -> None:
        """
        Insert a donor sequence at the specified position.

        Args:
            debug:
            abs_position (int): Absolute position for insertion (1-based)
            donor_seq (str): Donor sequence to insert
            donor_id (str): Identifier for the donor sequence
            tsd_length (int): Length of Target Site Duplication (TSD) to generate
            recursive (bool): Whether to use recursive insertion method
        """
        # Skip insertion if donor sequence is empty
        if not donor_seq:
            return

        # Convert 1-based position to 0-based for internal processing
        zero_based_position = abs_position - 1

        if not recursive:
            self.root = self._insert_iterative(self.root, zero_based_position, donor_seq, donor_id, tsd_length, debug)
        else:
            self.root = self._insert_recursive(self.root, zero_based_position, donor_seq, donor_id, tsd_length, debug)

    def _insert_recursive(self, node: SequenceNode, abs_position: int, donor_seq: str,
                          donor_id: str = None, tsd_length: int = 0, debug: bool = False) -> SequenceNode:
        """
        Recursively insert a donor sequence at the absolute position in the tree.

        Args:
            node (SequenceNode): Current node
            abs_position (int): Absolute position in the tree to insert at (0-based)
            donor_seq (str): Donor sequence to insert
            donor_id (str): Identifier for the donor sequence
            tsd_length (int): Length of Target Site Duplication (TSD) to generate

        Returns:
            SequenceNode: New node after insertion
        """
        # Skip insertion if donor sequence is empty
        if not donor_seq:
            return node

        # 创建donor节点UID
        donor_node_uid = self._get_next_uid()
        # 添加到嵌套关系图
        self.nesting_graph.add_node(donor_node_uid, donor_seq, donor_id, abs_position)

        # Calculate positions in tree
        node_start = node.left.total_length if node.left else 0
        node_end = node_start + node.length

        # Case 1: Position is in the current node's left subtree
        if abs_position <= node_start:
            if node.left:
                node.left = self._insert_recursive(node.left, abs_position, donor_seq, donor_id, tsd_length)
            else:
                # Insert as left child - 使用预先创建的UID
                node.left = self._create_node(donor_seq, True, donor_id, donor_node_uid)

            node.update()
            return node.balance()

        # Case 2: Position is inside the current node
        if node_start < abs_position < node_end:
            # Split this node
            rel_pos = abs_position - node_start
            left_data = node.data[:rel_pos]
            right_data = node.data[rel_pos:]

            # Handle TSD generation
            if tsd_length > 0:
                # Extract source TSD sequence from the original sequence
                source_tsd_seq = right_data[:min(tsd_length, len(right_data))]

                # Generate TSD sequences (potentially with mutations)
                tsd_5, tsd_3 = generate_TSD(source_tsd_seq, tsd_length)

                # Remove source TSD from right_data as it will be duplicated
                if len(source_tsd_seq) > 0:
                    right_data = right_data[len(source_tsd_seq):]

                # Add TSD sequences to the left and right data
                left_data = left_data + tsd_5
                right_data = tsd_3 + right_data

            # 保存当前节点的信息
            old_node_uid = node.uid
            is_current_donor = node.is_donor
            current_donor_id = node.donor_id

            # 创建左、右片段节点的UID
            left_node_uid = self._get_next_uid()
            right_node_uid = self._get_next_uid()

            # 添加左右片段节点到关系图
            self.nesting_graph.add_node(left_node_uid, left_data, current_donor_id, node_start)
            self.nesting_graph.add_node(right_node_uid, right_data, current_donor_id, abs_position + len(donor_seq))

            # 使用预设的UID创建新节点
            new_left = self._create_node(left_data, is_current_donor, current_donor_id, left_node_uid)
            if node.left:
                new_left.left = node.left
                new_left.update()
                # Balance left subtree
                new_left = new_left.balance()

            # 使用预设的UID创建右节点
            new_right = self._create_node(right_data, is_current_donor, current_donor_id, right_node_uid)
            if node.right:
                new_right.right = node.right
                new_right.update()
                # Balance right subtree
                new_right = new_right.balance()

            # 如果当前节点是donor，记录切割关系
            if is_current_donor:
                # 添加切割关系到嵌套关系图
                self.nesting_graph.add_cut_relation(
                    donor_node_uid,  # 切割者donor的UID
                    old_node_uid,    # 被切割donor的UID
                    left_node_uid,   # 切割后左片段的UID
                    right_node_uid   # 切割后右片段的UID
                )

            self._release_uid(old_node_uid)

            # 更新节点信息
            node.data = donor_seq
            node.length = len(donor_seq)
            node.is_donor = True
            node.donor_id = donor_id
            node.uid = donor_node_uid
            self.node_dict[donor_node_uid] = node

            # Set new children
            node.left = new_left
            node.right = new_right
            node.update()

            return node.balance()

        # Case 3: Position is in the current node's right subtree
        if abs_position >= node_end:
            if node.right:
                node.right = self._insert_recursive(node.right, abs_position - node_end, donor_seq, donor_id, tsd_length)
            else:
                # Insert as right child - 使用预先创建的UID
                node.right = self._create_node(donor_seq, True, donor_id, donor_node_uid)

            node.update()
            return node.balance()

        raise RuntimeError("[ERROR] Should not reach here")

    def _insert_iterative(self, node: SequenceNode, abs_position: int, donor_seq: str,
                          donor_id: str = None, tsd_length: int = 0, debug: bool = False) -> SequenceNode:
        """
        Iteratively insert a donor sequence at the absolute position in the tree.

        Args:
            node (SequenceNode): Current root node
            abs_position (int): Absolute position in the tree to insert at (0-based)
            donor_seq (str): Donor sequence to insert
            donor_id (str): Identifier for the donor sequence
            tsd_length (int): Length of Target Site Duplication (TSD) to generate

        Returns:
            SequenceNode: New root node after insertion
        """
        # Skip insertion if donor sequence is empty
        if not donor_seq:
            return node

        current = node
        parent_stack = []
        path_directions = []  # Record the path direction from root to current node ('left' or 'right')

        # 创建donor节点UID
        donor_node_uid = self._get_next_uid()
        # 添加到嵌套关系图
        self.nesting_graph.add_node(donor_node_uid, donor_seq, donor_id, abs_position)

        # Iteratively find insertion position
        while True:
            node_start = current.left.total_length if current.left else 0
            node_end = node_start + current.length

            # Case 1: Position is in the current node's left subtree
            if abs_position <= node_start:
                if current.left:
                    # Record parent node and direction for backtracking
                    parent_stack.append(current)
                    path_directions.append('left')
                    current = current.left
                else:
                    # Create new left child node - 使用预先创建的UID
                    current.left = self._create_node(donor_seq, True, donor_id, donor_node_uid)

                    current.update()
                    break

            # Case 2: Position is inside the current node
            elif node_start < abs_position < node_end:
                # Calculate relative position
                rel_pos = abs_position - node_start
                left_data = current.data[:rel_pos]
                right_data = current.data[rel_pos:]

                # Handle TSD generation
                if tsd_length > 0:
                    # Extract source TSD sequence from the original sequence
                    source_tsd_seq = right_data[:min(tsd_length, len(right_data))]

                    # Generate TSD sequences (potentially with mutations)
                    tsd_5, tsd_3 = generate_TSD(source_tsd_seq, tsd_length)

                    # Remove source TSD from right_data as it will be duplicated
                    if len(source_tsd_seq) > 0:
                        right_data = right_data[len(source_tsd_seq):]

                    # Add TSD sequences to the left and right data
                    left_data = left_data + tsd_5
                    right_data = tsd_3 + right_data

                # 保存当前节点信息
                old_node_uid = current.uid
                is_current_donor = current.is_donor
                current_donor_id = current.donor_id

                # 创建左、右片段节点UID
                left_node_uid = self._get_next_uid()
                right_node_uid = self._get_next_uid()

                # 添加左右片段节点到关系图
                self.nesting_graph.add_node(left_node_uid, left_data, current_donor_id, node_start)
                self.nesting_graph.add_node(right_node_uid, right_data, current_donor_id, abs_position + len(donor_seq))

                # 使用预设的UID创建左节点
                new_left = self._create_node(left_data, is_current_donor, current_donor_id, left_node_uid)
                if current.left:
                    new_left.left = current.left
                    new_left.update()

                # 使用预设的UID创建右节点
                new_right = self._create_node(right_data, is_current_donor, current_donor_id, right_node_uid)
                if current.right:
                    new_right.right = current.right
                    new_right.update()

                # 如果当前节点是donor，记录切割关系
                if is_current_donor:
                    # 添加切割关系到嵌套关系图
                    self.nesting_graph.add_cut_relation(
                        donor_node_uid,  # 切割者donor的UID
                        old_node_uid,    # 被切割donor的UID
                        left_node_uid,   # 切割后左片段的UID
                        right_node_uid   # 切割后右片段的UID
                    )

                self._release_uid(old_node_uid)

                # 更新节点信息
                current.data = donor_seq
                current.length = len(donor_seq)
                current.is_donor = True
                current.donor_id = donor_id
                current.uid = donor_node_uid
                self.node_dict[donor_node_uid] = current

                # Set new children
                current.left = new_left
                current.right = new_right
                current.update()
                break

            # Case 3: Position is in the current node's right subtree
            elif abs_position >= node_end:
                if current.right:
                    # Record parent node and direction for backtracking
                    parent_stack.append(current)
                    path_directions.append('right')
                    # Adjust absolute position to fit the right subtree's relative position
                    abs_position -= node_end
                    current = current.right
                else:
                    # Create new right child node - 使用预先创建的UID
                    current.right = self._create_node(donor_seq, True, donor_id, donor_node_uid)

                    current.update()
                    break
            else:
                raise RuntimeError("[ERROR] Should not reach here")

        # Backtrack and update node heights and total lengths while executing balance
        while parent_stack:
            parent = parent_stack.pop()
            direction = path_directions.pop()

            # Update parent node's child reference
            if direction == 'left':
                # Balance current node using helper method
                current = current.balance()
                parent.left = current
            else:  # 'right'
                # Balance current node using helper method
                current = current.balance()
                parent.right = current

            parent.update()

            # Balance parent node
            current = parent.balance()

        return current

    def donors(self, seq_id: str) -> Tuple[List[SeqRecord], List[SeqRecord]]:
        """
        收集所有donor节点并重建嵌套donor。
        利用嵌套关系图执行高效重建。

        Args:
            seq_id (str): 原始序列ID

        Returns:
            Tuple[List[SeqRecord], List[SeqRecord]]:
                - 普通donor记录（不包括被重建donor覆盖的）
                - 重建的donor记录
        """
        # 收集所有donor节点
        donor_records = self._collect_donor_records(seq_id)

        # 使用嵌套关系图重建donor
        reconstructed_donors, excluded_uids = self.nesting_graph.reconstruct_donors(seq_id)

        # 过滤掉被重建donor覆盖的记录
        if excluded_uids:
            donor_records = [record for record in donor_records
                             if record.annotations.get("uid") not in excluded_uids]

        return donor_records, reconstructed_donors

    def _collect_donor_records(self, seq_id: str) -> List[SeqRecord]:
        """
        从树中收集所有donor节点，生成SeqRecord记录

        Args:
            seq_id (str): 原始序列ID

        Returns:
            List[SeqRecord]: Donor记录列表
        """
        donor_records = []
        abs_position_map = self._calculate_absolute_positions()

        # 遍历所有节点
        for node in self:
            if node.is_donor:
                # 获取节点的绝对位置信息
                start_pos = abs_position_map.get(node.uid, 0)
                end_pos = start_pos + node.length

                # 转换为1-based索引用于输出
                start_pos_1based = start_pos + 1
                end_pos_1based = end_pos

                # 创建donor ID
                donor_id = f"{seq_id}_{start_pos_1based}_{end_pos_1based}-+-{node.length}"
                if node.donor_id:
                    donor_id += f"-{node.donor_id}"

                # 创建record
                donor_record = create_sequence_record(node.data, donor_id)
                donor_record.annotations["uid"] = node.uid
                donor_record.annotations["position"] = start_pos_1based
                donor_record.annotations["length"] = node.length

                # 添加到结果列表
                donor_records.append(donor_record)

        return donor_records

    def _calculate_absolute_positions(self) -> Dict[int, int]:
        """
        计算树中每个节点的绝对位置

        Returns:
            Dict[int, int]: 节点UID到绝对位置的映射
        """
        positions = {}

        def _traverse(node, current_pos=0):
            if not node:
                return current_pos

            # 处理左子树
            left_end_pos = _traverse(node.left, current_pos)

            # 计算当前节点位置
            node_pos = left_end_pos
            positions[node.uid] = node_pos

            # 处理右子树
            right_end_pos = _traverse(node.right, node_pos + node.length)

            return right_end_pos

        _traverse(self.root, 0)
        return positions

    def to_graphviz_dot(self) -> str:
        """
        Generate a Graphviz DOT representation of the tree structure for visualization.

        Returns:
            str: Graphviz DOT format string
        """
        if not self.root:
            return "digraph SequenceTree { }"

        # Initialize the DOT string with graph declaration
        dot_str = ["digraph SequenceTree {",
                   "  bgcolor=\"#FFF\";",
                   "  node [fontcolor=\"#000\", shape=box, style=filled];",
                   "  edge [fontcolor=\"#000\", penwidth=2.0];"]

        # Generate nodes and edges through recursive traversal
        nodes, edges = SequenceTree._build_graphviz_dot_nodes_edges(self.root, self.nesting_graph)

        # Add all nodes and edges to the DOT string
        for node in nodes:
            dot_str.append(f"  {node}")
        for edge in edges:
            dot_str.append(f"  {edge}")

        dot_str.append('}')
        return '\n'.join(dot_str)

    @staticmethod
    def _build_graphviz_dot_nodes_edges(node: SequenceNode, nesting_graph: HierarchicalNestingGraph,
                                        abs_pos: int = 0) -> tuple:
        """
        Recursively build nodes and edges for Graphviz visualization.

        Args:
            node (SequenceNode): Current node
            abs_pos (int): Current absolute position (0-based)

        Returns:
            tuple: (nodes list, edges list)
        """
        if not node:
            return [], []

        nodes = []
        edges = []

        # Calculate positions
        left_length = node.left.total_length if node.left else 0

        # Calculate start and end positions for display
        start_pos = abs_pos + left_length
        end_pos = start_pos + node.length

        # Convert to 1-based positions for display
        start_pos_1based = start_pos + 1
        end_pos_1based = end_pos

        # Use uid directly as node ID
        node_id = f"node_{node.uid}"

        # Determine node type and color
        if node.is_donor:
            node_type = "Donor"
            fill_color = "lightblue"
        else:
            node_type = "Acceptor"
            fill_color = "lightgreen"

        # Process fragment and nesting information
        cut_half = ""

        # 重新设计颜色赋值逻辑，使其更加明确
        # 1. 先设置基础颜色（donor为蓝色，acceptor为绿色）
        # 2. 如果是切割片段，改为粉色
        # 3. 如果有嵌套关系，改为黄色
        # 4. 如果同时满足2和3，则为紫色

        # Check if this is a fragment of a cut donor
        if nesting_graph.is_fragment(node.uid):
            # Get fragment info (original_uid, position, is_left, cutter_uid)
            fragment_info = nesting_graph.fragments.get(node.uid)
            if fragment_info:
                _, pos, is_left, cutter_uid = fragment_info
                half_type = "L" if is_left else "R"
                cut_half = f"Cut: {half_type}, by {cutter_uid}"
                fill_color = "lightpink"  # Cut fragments shown in pink

        # Create node label with position information
        label = "".join([node_type, " | ", str(node.uid), "\\n",
                         str(start_pos_1based), "\\l",
                         str(end_pos_1based), "\\l",
                         "Length: ", str(node.length), "\\n",
                         cut_half])

        # Add the node to the nodes list
        nodes.append(f'{node_id} [label="{label}", fillcolor="{fill_color}"];')

        # Process left child if exists
        if node.left:
            # Left child should start at the same absolute position as its parent
            left_abs_pos = abs_pos
            left_nodes, left_edges = SequenceTree._build_graphviz_dot_nodes_edges(node.left, nesting_graph, left_abs_pos)
            nodes.extend(left_nodes)
            edges.extend(left_edges)

            # Add edge from this node to left child using uid
            left_id = f"node_{node.left.uid}"
            edges.append(f'{node_id} -> {left_id} [label="L", color="blue"];')

        # Process right child if exists
        if node.right:
            # Right child starts at the end position of the current node
            right_abs_pos = abs_pos + left_length + node.length
            right_nodes, right_edges = SequenceTree._build_graphviz_dot_nodes_edges(node.right, nesting_graph, right_abs_pos)
            nodes.extend(right_nodes)
            edges.extend(right_edges)

            # Add edge from this node to right child using uid
            right_id = f"node_{node.right.uid}"
            edges.append(f'{node_id} -> {right_id} [label="R", color="red"];')

        return nodes, edges
